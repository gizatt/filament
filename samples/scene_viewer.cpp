/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "app/Config.h"
#include "app/FilamentApp.h"
#include "app/MeshAssimp.h"

#include <filament/Engine.h>
#include <filament/LightManager.h>
#include <filament/Material.h>
#include <filament/MaterialInstance.h>
#include <filament/RenderableManager.h>
#include <filament/TransformManager.h>
#include <filament/Scene.h>
#include <filament/Texture.h>
#include <filament/IndirectLight.h>

#include <utils/Path.h>
#include <utils/EntityManager.h>

#include <math/mat3.h>
#include <math/mat4.h>
#include <math/vec3.h>

#include <getopt/getopt.h>

#include <stb_image.h>

#include <memory>
#include <map>
#include <string>
#include <vector>

// Stupid hack to force unistd.h's getopt to not
// import and clobber the custom getopt defined above.
#define _GETOPT_H
#include <Eigen/Dense>
#include <stanford_scene_database/common/Scene.h>

using namespace math;
using namespace filament;
using namespace filamat;
using namespace utils;

static std::string default_scene_name;
static utils::Path database_dir;

static std::vector<std::map<std::string, MaterialInstance*>> g_materialInstancesInstances;
static std::unique_ptr<MeshAssimp> g_meshSet;
static const Material* g_material;
static Entity g_light, g_light_2, g_light_3;

static Config g_config;

static void printUsage(char* name) {
    std::string usage(
            "scene_viewer displays stanford scenes using the filament renderer\n"
            "Usage:\n"
            "    scene_viewer [options] database_dir default_scene_name\n"
            "Options:\n"
            "   --help, -h\n"
            "       Prints this message\n\n"
            "   --ibl=<path to cmgen IBL>, -i <path>\n"
            "       Applies an IBL generated by cmgen's deploy option\n\n"
    );
    std::cout << usage;
}

static int handleCommandLineArgments(int argc, char* argv[], Config* config) {
    static constexpr const char* OPTSTR = "hi:";
    static const struct option OPTIONS[] = {
            { "help",           no_argument,       nullptr, 'h' },
            { "ibl",            required_argument, nullptr, 'i' },
            { 0, 0, 0, 0 }  // termination of the option list
    };
    int opt;
    int option_index = 0;
    while ((opt = getopt_long(argc, argv, OPTSTR, OPTIONS, &option_index)) >= 0) {
        std::string arg(optarg ? optarg : "");
        switch (opt) {
            default:
            case 'h':
                printUsage(argv[0]);
                exit(0);
            case 'i':
                config->iblDirectory = arg;
                break;
            case 'v':
                config->splitView = true;
                break;
        }
    }

    return optind;
}

static void cleanup(Engine* engine, View* view, Scene* scene) {
    for (auto& g_materialInstances : g_materialInstancesInstances){
        for (auto& item : g_materialInstances) {
            auto materialInstance = item.second;
            engine->destroy(materialInstance);
        }
    }
    g_meshSet.reset(nullptr);
    engine->destroy(g_material);

    EntityManager& em = EntityManager::get();
    engine->destroy(g_light);
    em.destroy(g_light);
}

static void setup(Engine* engine, View* view, Scene* scene) {
    // Load in scene
    stanford_scene_database::Parameters ssd_params;
    ssd_params.databaseDirectory = database_dir.getPath();
    ssd_params.defaultScene = default_scene_name;
    ssd_params.textQuery = "@";

    stanford_scene_database::Assets ssd_assets;
    stanford_scene_database::Scene ssd_scene;
    ssd_scene.Load(ssd_params, ssd_params.defaultScene, ssd_assets);

    g_meshSet = std::make_unique<MeshAssimp>(*engine);

    auto& rcm = engine->getRenderableManager();
    auto& tcm = engine->getTransformManager();

    // Load in each model in the scene

    bool got_first_tf = false;
    mat4f first_inv_tf;
    for (auto& model_instance : ssd_scene.getAllModels()) {
        g_materialInstancesInstances.emplace_back();
        auto& g_materialInstances = g_materialInstancesInstances.back(); 
        utils::Path full_model_path = database_dir + "models" +
            (model_instance->GetModel().Hash() + ".gltf");
        std::cout << "Adding model with filename " << full_model_path << std::endl;
        std::vector<utils::Entity> new_entities;

        g_meshSet->addFromFile(full_model_path, g_materialInstances, false, &new_entities);

        if (new_entities.size() == 0){
            std::cerr << "Added zero entities???" << std::endl;
            continue;
        }

        // TF appropriately
        mat4f tf_out;
        auto tf_in = model_instance->GetTransform();
        for (int i=0; i<4; i++){
            for (int j=0; j<4; j++){
                tf_out[i][j] = tf_in[i][j];
            }
        }

        auto rooti = tcm.getInstance(new_entities.back());
        tcm.setTransform(rooti, tf_out);

        if (!got_first_tf){
            Eigen::Matrix4f tf_eigen;
            for (int i=0; i<4; i++){
                for (int j=0; j<4; j++){
                    tf_eigen(i, j) = tf_out[i][j];
                }
            }            
            tf_eigen.block<3, 3>(0, 0) = tf_eigen.block<3, 3>(0, 0).inverse();
            tf_eigen.block<3, 1>(0, 3) = -tf_eigen.block<3, 3>(0, 0) * tf_eigen.block<3, 1>(0, 3);
            tf_eigen(3, 3) = 1.;
            for (int i=0; i<4; i++){
                for (int j=0; j<4; j++){
                    first_inv_tf[i][j] = tf_eigen(i, j);
                }
            }
            got_first_tf = true;
        }
    }

    float maxExtent = 0;
    maxExtent = std::max(g_meshSet->maxBound.x - g_meshSet->minBound.x, g_meshSet->maxBound.y - g_meshSet->minBound.y);
    maxExtent = std::max(maxExtent, g_meshSet->maxBound.z - g_meshSet->minBound.z);
    float scaleFactor = 2.0f / 50.;

    float3 center = -1 * (g_meshSet->maxBound + g_meshSet->minBound) / 2.0f;
    center.z -= 4.0f / scaleFactor;
    std::cout << "Maxbound: " << g_meshSet->maxBound << std::endl;
    std::cout << "Minbound: " << g_meshSet->minBound << std::endl;

    auto rooti = tcm.getInstance(g_meshSet->rootEntity);
    std::cout << "Rooti:" << rooti << std::endl;
    mat4f scale_fix = mat4f::scale(float3(scaleFactor));
    mat4f extra_rotate;
    extra_rotate[1][1] = 0;
    extra_rotate[1][2] = -1;
    extra_rotate[2][1] = 1;
    extra_rotate[2][2] = 0;
    scale_fix *= extra_rotate;
    std::cout << "TF: " <<  scale_fix << std::endl;
    tcm.setTransform(rooti, scale_fix);
    

    for (auto renderable : g_meshSet->getRenderables()) {
        if (rcm.hasComponent(renderable)) {
            auto instance = rcm.getInstance(renderable);
            rcm.setCastShadows(instance, true);
            rcm.setReceiveShadows(instance, true);
            scene->addEntity(renderable);
        }
    }

    g_light = EntityManager::get().create();
    LightManager::Builder(LightManager::Type::SUN)
            .color(Color::toLinear<ACCURATE>(sRGBColor(0.98f, 0.92f, 0.89f)))
            .intensity(50000)
            .direction({ 0.1, -0.9, 0.1 })
            .sunAngularRadius(1.9f)
            .castShadows(true)
            .build(*engine, g_light);
    scene->addEntity(g_light);
/*
    g_light_2 = EntityManager::get().create();
    LightManager::Builder(LightManager::Type::SUN)
            .color(Color::toLinear<ACCURATE>(sRGBColor(0.98f, 0.92f, 0.89f)))
            .intensity(110000)
            .direction({ -0.7, 1, 0.8 })
            .sunAngularRadius(1.9f)
            .castShadows(true)
            .build(*engine, g_light_2);
    scene->addEntity(g_light_2);    

    g_light_3 = EntityManager::get().create();
    LightManager::Builder(LightManager::Type::SPOT)
            .color(Color::toLinear<ACCURATE>(sRGBColor(0.98f, 0.92f, 0.89f)))
            .intensity(100000)
            .position({ 0., 0, 0. })
            .castShadows(true)
            .build(*engine, g_light_3);
    scene->addEntity(g_light_3);    */
}

int main(int argc, char* argv[]) {
    int option_index = handleCommandLineArgments(argc, argv, &g_config);
    int num_args = argc - option_index;
    if (num_args != 2) {
        printUsage(argv[0]);
        return 1;
    }

    database_dir = utils::Path(argv[option_index]);
    default_scene_name = argv[option_index+1];

    FilamentApp& filamentApp = FilamentApp::get();
    filamentApp.run(g_config, setup, cleanup);

    return 0;
}
